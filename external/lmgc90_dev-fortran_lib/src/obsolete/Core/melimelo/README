
A propos des bonnes pratiques d'utilisation de melimelo :

Avec tout les pointeurs qui se promènent il est souvent
difficile de savoir comment faire les choses proprement
sans faire des tonnes d'allocations/libération/copies.

Le parti à été pris que, dans melimelo, quand on voulait
ajouter un T_object dans un des conteneurs, on donne en
entrées un pointeur alloué. Et pour chaque appele la
mémoire doit être allouée indépendement.  Donc si vous
avez un c5 = (/'QE4xx', 'M2DNL, 'Steel'/) qui est le
même pour tout vos élements, vous devez avoir en mémoire
une copie de ce c5 pour chacun de vos élements ! 

Moralement cela pourrait marcher avec une seule allocation
puisque un T_object marche par association à l'initialisation
par défaut (en utilisant add_object_to_container(blablalbla)).
Cependant lors de la libération mémoire, via un appel à
erase_container, une erreur de segmentation sera générée car
pour ce même vecteur sera libéré pour chaque objet qui pointait
sur lui (donc pour chaque element) ; pour éviter ce genre de
problèmes il faudrait une structure de 'smart pointer'.

Une autre manière de pallier ce problème serait d'avoir une
fonction destroy_container, qui, elle, ne fasse pas la
désallocation des pointeurs quand il y en dans la structure
de données. Mais cela imposerait que à l'extérieur de la
structure de données on ait gardé une référence sur chacun
des espace mémoire alloué sous peine d'avoir des fuites
mémoires. En effet si on détruit tout la structure de donnée
sans désalloué les pointeurs, ils resteront dans la mémoire, 
il faut donc les désallouer après avoir détruit la structure
de donnée.... qui tenait toute les références.

J'ai pris le parti de faire de l'association à l'initialisation
car ma politique d'interface avec Python est : dans le wrap,
réalloction et copie des données du python dans le fortran.
Afin d'éviter une deuxième allocation/copie dans le fortran,
utiliser directement le pointeur alloué dans le wrap me semble 
plus intéressant.

On peut très bien imaginer de faire une deuxième interface
dans le module mélimelo qui serait copy_in_a_bulk, qui elle
ferait, par défaut, une allocation et recopierait dedans.
Dans ce cas-là le erase_container ne générerait jamais
d'erreur de segmentation.

A regarder de plus près : comment j'ai foutu les constructeurs
par copie... à voir comment veut-on les utiliser. Je crois que
faire une copie réelle par allocation (comme fait) est ce qu'il
y a de plus sûr et cohérent avec la logique prise jusqu'à maintenant.

Le get_data de linkedlist.f90 fait une copie dans la valeur de retour,
pas une référence.

A propos du visiteur : les modules blmty, nodty et tacty sont
restés très proche des modules originaux. Cependant il faudrait
peut-être plutôt dans faire quelque chose de similaire à display,
mais avec le visitor, et chaque objet sait comment se 'visiter'.
Le mieux serait peut–être même de faire en sorte que le display
soit une sorte de 'what' du visiteur ?

Concernant les test : un test marqué 'PASSED' ne veut pas dire
que l'on a le résultat obtenu ! Il faut aller regarder les logs
et probablement même le source de l'exemple pour se convaincre
que le résultat obtenue est bien celui escompté.
